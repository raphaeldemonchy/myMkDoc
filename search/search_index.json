{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to HessrType","text":"<p>On this site you could find a nice documentation of our RType project.</p> <p>The aim of this project is to re-create the famous RType arcade game in C++ and implement client-server architecture with multi-player mode. A modular game engine was to be developed, with content creation tools. Possibility of a single-player mode with AI. The project imposes professional rigor in both the design and writing of the code, and the optimization of client-server communication. The game's performance is up to the highest standards.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Compability</li> <li>Built-With</li> <li>StarterPack</li> <li>Requirements</li> <li>Installation</li> <li>Start-Game</li> <li>Documentation</li> <li>Contributing</li> <li>How-to-participate</li> <li>Todo-List</li> <li>Crew</li> <li>License</li> </ul> <p>## Compability</p> <p> </p>"},{"location":"#built-with","title":"Built-With","text":"<p>\ud83d\udcc1 The project uses two libraries:</p> <ul> <li>SFML: The library used to display.</li> <li>Boost: The library used to manage communication, threads and processes.</li> </ul>"},{"location":"#starterpack","title":"StarterPack","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Conan version ${\\color{red}2.0.13}$</li> <li>CMake version ${\\color{red}3.0.0}$</li> <li>Xorg/System version ${\\color{red}x.x.x}$</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>step 1 <pre><code>git clone git@github.com:EpitechPromo2026/B-CPP-500-MAR-5-1-rtype-maori.dino.git\n</code></pre></p> <p>step 2 <pre><code>cd B-CPP-500-MAR-5-1-rtype-maori.dino.git\n</code></pre></p> <p>step 3 <pre><code>./install.sh\n</code></pre></p>"},{"location":"#start-game","title":"Start-Game","text":"<p>step 4 <pre><code>./r_type_server\n</code></pre></p> <p>step 5 <pre><code>./r_type_client\n</code></pre></p>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the project's technical documentation in our Github-Wiki. The documentation is divided into 3 main parts, the server, the client and the game engine, in which you'll find instructions for using the game engine.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to contribute to a project and make it better, your help is very welcome. Contributing is also a great way to learn more about social coding on Github, new technologies and and their ecosystems and how to make constructive, helpful bug reports, feature requests and the noblest of all contributions: a good, clean pull request.</p>"},{"location":"#how-to-participate","title":"How-to-participate","text":"<ul> <li>Follow instruction in CONTRIBUTING.md</li> </ul>"},{"location":"#todo-list","title":"TODO-LIST","text":"<ul> <li>We have some ideas for functionality but our team is overwhelmed, if the force is with you do not hesitate to consult our Todo-List.txt and follow the procedure of contribution, in case of problem do not hesitate to contact one of the members of our team.</li> </ul>"},{"location":"#crew","title":"Crew","text":"Roles Name Project Leader &amp; Engineer Maori Dino AI Engineer Mohamed Mansour Network &amp; Game Engineer Yanis Denat Network &amp; Game Engineer Thibault Tran Game Engineer Raphael de Monchy"},{"location":"#license","title":"License","text":"<p>Distributed under the MIT License. See <code>LICENSE</code> for more information.</p>"},{"location":"RTypes_docs/RTypes_docs/","title":"RType_docsTable of Contents","text":"<ul> <li>Client</li> <li>Server</li> <li>GameEngine</li> </ul> <p>back to top</p>"},{"location":"RTypes_docs/RTypes_docs/#client","title":"Client","text":"<ul> <li>Introduction</li> <li>User-Interface</li> <li>GameEngine-Integration</li> <li>Mode</li> <li>Multi-Player</li> <li>Single-Player</li> <li>Network-Protocole</li> </ul>"},{"location":"RTypes_docs/RTypes_docs/#introduction","title":"Introduction","text":"<p>The client component of this project is the interactive interface through which players engage with the re-created RType arcade game.  It serves as the point of access to the gaming experience and facilitates both single-player and multi-player modes. The client is meticulously  designed and developed in C++ to provide a user-friendly, immersive, and responsive gaming environment.</p>"},{"location":"RTypes_docs/RTypes_docs/#user-interface","title":"User Interface","text":"<p>The client offers a visually appealing and intuitive user interface that allows players to navigate the game and much more...</p>"},{"location":"RTypes_docs/RTypes_docs/#gameengine-integration","title":"GameEngine-Integration","text":"<p>It seamlessly integrates with the modular game engine, ensuring the efficient execution of game mechanics, graphics rendering, and audio effects.</p>"},{"location":"RTypes_docs/RTypes_docs/#mode","title":"Mode","text":"<p>Players can connect to the server create their lobby and join each others and participate in multiplayer matches, battling together in real-time against AI opponents. The client facilitates communication with the server for synchronized gameplay.</p> <p>For those who prefer solo gaming you can challenge AI opponents, adding an extra layer of excitement to the gaming experience.</p>"},{"location":"RTypes_docs/RTypes_docs/#multi-player","title":"Multi-Player","text":""},{"location":"RTypes_docs/RTypes_docs/#single-player","title":"Single-Player","text":""},{"location":"RTypes_docs/RTypes_docs/#network-protocols","title":"Network-Protocols","text":"<p>The client uses a combination of network protocols for seamless gaming. It employs [TCP] for menu navigation, room creation, and other interactions, ensuring data integrity and reliability. During actual gameplay, the client switches to [UDP] for low-latency communication, delivering a responsive and immersive gaming experience.</p> <p>back to top</p>"},{"location":"RTypes_docs/RTypes_docs/#_1","title":"Getting started","text":""},{"location":"RTypes_docs/RTypes_docs/#server","title":"Server","text":"<ul> <li>Introduction</li> <li>Protocole-TCP/UDP</li> <li>TCP</li> <li> <p>UDP</p> </li> <li> <p>Rooms</p> </li> </ul>"},{"location":"RTypes_docs/RTypes_docs/#protocole-tcpudp","title":"[Protocole-TCP/UDP]","text":"TCP UDP"},{"location":"RTypes_docs/RTypes_docs/#rooms","title":"[Rooms]","text":"<p>back to top</p>"},{"location":"RTypes_docs/RTypes_docs/#_2","title":"Getting started","text":""},{"location":"RTypes_docs/RTypes_docs/#game-engine-ecs","title":"Game-Engine [ECS]","text":"<ul> <li>[ Structure ] </li> <li>Schema-Layer/subsystem</li> <li>[E]ntity</li> <li>[C]omponents</li> <li>[S]ystems</li> <li>[ Usage] </li> <li>Beginner</li> <li>Advanced</li> </ul>"},{"location":"RTypes_docs/RTypes_docs/#structure","title":"[ Structure ]","text":"Schema Layer/subsystem <pre><code>graph LR\n\n        K([SYS-Colision]) --&gt; J{Systems}\n        H([SYS-AI]) --&gt; J{Systems}\n        V([SYS-Weapon]) --&gt; J{Systems}\n\n        J{Systems} --&gt; X{Components}\n\n\n    A[EntityManager] --&gt; B(Entity-Player)\n    A[EntityManager] --&gt; S(Entity-Mob)\n    A[EntityManager] --&gt; W(Entity-Bullet)\n\n    B --&gt; X{Components}\n    S --&gt; X{Components}\n    W --&gt; X{Components}\n    X --&gt;Y[Health]\n    X --&gt;E[HitBox]\n    X --&gt;F[Position]</code></pre> <pre><code>stateDiagram-v2\n    state GameEngine[ECS] {\n            state Entities {\n                direction LR\n                state Components {\n                    direction LR\n                    state Damage {\n                        direction LR\n                        damage\n                    }\n                    state Life {\n                        direction LR\n                        life\n                   }\n                   state HitBox {\n                        XY\n                   }\n               }\n\n            }\n            state Systems {\n                direction LR\n                state SysRender {\n                    direction LR\n                    updateRender()\n                }\n                state SysShoot {\n                    direction LR\n                    updateShoot()\n                }\n                state SysAI {\n                    direction LR\n                    updateAI()\n                }\n            }\n    }</code></pre>"},{"location":"RTypes_docs/RTypes_docs/#_3","title":"Getting started","text":"[E]ntity <p>EntityManager.hpp</p> <pre><code>namespace GameEngine {\n\nclass EntityManager {\npublic:\nEntityManager() {}\nEntityManager(EntityManager &amp;entityManager) {\n_listEntity = entityManager.getEntities();\n}\n~EntityManager() {}\n\nstd::shared_ptr&lt;Entity&gt;&amp; createEntity() {\n_entityPtr = std::make_shared&lt;Entity&gt;(1);\nreturn _entityPtr;\n}\n\nstd::shared_ptr&lt;Entity&gt;&amp; addEntity(Entity entity) {\n_entityPtr = std::make_shared&lt;Entity&gt;(entity);\n_listEntity.push_back(_entityPtr);\nreturn _entityPtr;\n}\n\nstd::shared_ptr&lt;Entity&gt;&amp; getEntity(std::string uuid) {\nfor (auto&amp; entityPtr : _listEntity) {\nif (entityPtr-&gt;getUuid() == uuid) {\nreturn entityPtr;\n}\n}\nthrow std::runtime_error(\"Entity not found for uuid \" + uuid);\n}\n\nstd::shared_ptr&lt;Entity&gt;&amp; getEntityById(unsigned int id) {\nfor (auto&amp; entityPtr : _listEntity) {\nif (entityPtr-&gt;getId() == id) {\nreturn entityPtr;\n}\n}\nthrow std::runtime_error(\"Entity not found\");\n}\n\nstd::shared_ptr&lt;EntityManager&gt; getEntityManager() {\nreturn std::make_shared&lt;EntityManager&gt;(*this);\n}\n\nstd::list&lt;std::shared_ptr&lt;Entity&gt;&gt;&amp; getEntities() {\nreturn _listEntity;\n}\n\nstd::list&lt;std::shared_ptr&lt;Entity&gt;&gt; getEntitiesByType(int entityType) {\nstd::list&lt;std::shared_ptr&lt;Entity&gt;&gt; listEntity;\nfor (std::shared_ptr&lt;Entity&gt; &amp;entityPtr : _listEntity) {\nif (entityPtr.get()-&gt;getType() == entityType) {\nlistEntity.push_back(entityPtr);\n}\n}\nreturn listEntity;\n}\n\nstd::shared_ptr&lt;Entity&gt; getEntityByType(int entityType) {\nfor (std::shared_ptr&lt;Entity&gt; &amp;entityPtr : _listEntity) {\nif (entityPtr.get()-&gt;getType() == entityType) {\nreturn entityPtr;\n}\n}\nreturn nullptr;\n}\n\nstd::mutex &amp;getMutex() {\nreturn _mutex;\n}\n\nvoid deleteEntity(std::string uuid) {\nstd::lock_guard&lt;std::mutex&gt; lock(_mutex);\nfor (std::shared_ptr&lt;Entity&gt; entityPtr : _listEntity) {\nif (entityPtr-&gt;getUuid() == uuid) {\n_listEntity.remove(entityPtr);\nreturn;\n}\n}\n// unlock();\n}\n\nbool try_lock() {\nreturn _mutex.try_lock();\n}\n\nvoid lock() {\n_mutex.lock();\n}\n\nvoid unlock() {\n_mutex.unlock();\n}\n\nprivate:\nstd::list&lt;std::shared_ptr&lt;Entity&gt;&gt; _listEntity;\nstd::shared_ptr&lt;Entity&gt; _entityPtr;\nstd::mutex _mutex;\n};\n\n}\n</code></pre>"},{"location":"RTypes_docs/RTypes_docs/#_4","title":"Getting started","text":"<p>Entity.hpp</p> <pre><code>using namespace GameEngine;\n\nnamespace GameEngine {\nclass Entity {\npublic:\nEntity() : _id(84), _entityType(42) {}\nEntity(unsigned int id, int type) : _id(id), _entityType(type), _isDeath(false) {\n_Destroy.timeout_ = 0.03;\n}\n\nEntity(int type) : _id(0), _entityType(type), _isDeath(false) {\n_Destroy.timeout_ = 0.03;\n}\n\nEntity(const Entity &amp;entity) {\n_id = entity._id;\n_entityType = entity._entityType;\n_entityContent = entity._entityContent;\n_isDeath = entity._isDeath;\n_uuid = entity._uuid;\n}\n\nvoid init() {\n_uuid = boost::uuids::to_string(boost::uuids::random_generator()());\n// std::cout &lt;&lt; \"UUID: \" &lt;&lt; _uuid &lt;&lt; std::endl;\n}\n\n~Entity() {}\n\ntemplate &lt;class Archive&gt;\nvoid serialize(Archive &amp; ar, const unsigned int version) {\nar &amp; _id;\nar &amp; _uuid;\nar &amp; _entityType;\nar &amp; _entityContent;\nar &amp; _isDeath;\n}\n\nbool canDestroy() {\nif (_Destroy.can_execute())\nreturn true;\nreturn false;\n}\n\nvoid startDestroy() {\n_Destroy.Start();\n}\n\nbool DestroyStarted(){return _Destroy.isStarted();}\n\nunsigned int getId() const {\nreturn _id;\n}\n\nstd::string getUuid() {\nreturn _uuid;\n}\n\ntemplate &lt;typename T&gt;\nvoid addComponent(T &amp;component) {\n_entityContent.push_back(component);\n}\n\ntemplate &lt;typename T&gt;\nvoid deleteComponent(std::shared_ptr&lt;T&gt; component) {\n_entityContent.remove(component);\n}\n\ntemplate &lt;typename T&gt;\nstd::shared_ptr&lt;T&gt; getComponentByType(CONFIG::CompType type) {\nfor (auto &amp;component : _entityContent) {\nif (component.get()-&gt;getType() == type)\nreturn std::dynamic_pointer_cast&lt;T&gt;(component);\n}\nreturn nullptr;\n}\n\ntemplate &lt;typename T&gt;\nstd::vector&lt;std::shared_ptr&lt;T&gt;&gt; getComponentsByType(CONFIG::CompType type) {\nstd::vector&lt;std::shared_ptr&lt;T&gt;&gt; result;\nfor (auto &amp;component : _entityContent) {\nif (component-&gt;getType() == type) {\nauto derivedComponent = std::dynamic_pointer_cast&lt;T&gt;(component);\nif (derivedComponent) {\nresult.push_back(derivedComponent);\n}\n}\n}\nreturn result;\n}\n\ntemplate &lt;typename T&gt;\nstd::shared_ptr&lt;T&gt; getComponentById(int id) {\nfor (auto &amp;component : _entityContent) {\nif (component.get()-&gt;getId() == id)\nreturn component;\n}\nreturn nullptr;\n}\n\ntemplate &lt;typename T&gt;\nstd::shared_ptr&lt;T&gt; getComponentByUuid(std::string uuid) {\nfor (auto &amp;component : _entityContent) {\nif (component.get()-&gt;getUuid() == uuid)\nreturn component;\n}\nreturn nullptr;\n}\n\nstd::list&lt;std::shared_ptr&lt;AComponent&gt;&gt; &amp;getComponents() {\nreturn _entityContent;\n}\n\nvoid setEntityContent(std::list&lt;std::shared_ptr&lt;AComponent&gt;&gt; &amp;entity) {\n_entityContent = entity;\n}\n\nvoid setIsDeath(bool status){_isDeath = status;}\nvoid setType(int type) {_entityType = type;}\nint getType() const {return _entityType;}\nint getIsDeath(){return _isDeath;}\nstd::string getUuid() const {return _uuid;}\n\nvoid setId(unsigned int id) {\n_id = id;\n}\n\nprivate:\nTimeout _Destroy;\nbool _isDeath;\nstd::list&lt;std::shared_ptr&lt;AComponent&gt;&gt; _entityContent;\nunsigned int _id;\nint _entityType;\nstd::string _uuid;\n};\n}\n</code></pre>"},{"location":"RTypes_docs/RTypes_docs/#_5","title":"Getting started","text":"[C]omponents <p>IComponent.hpp</p> <pre><code>namespace GameEngine {\n\nclass IComponent {\npublic:\nvirtual ~IComponent() = default;\nvirtual CONFIG::CompType getType() = 0;\nvirtual void setType(const CONFIG::CompType type) = 0;\nvirtual int getId() = 0;\nvirtual std::string getUuid() = 0;\nvirtual void setId(const int id) = 0;\ntemplate &lt;typename Archive&gt;\nvoid serialize(Archive&amp; ar, const unsigned int version) {}\n};\n}\n</code></pre>"},{"location":"RTypes_docs/RTypes_docs/#_6","title":"Getting started","text":"<p>AComponent.hpp</p> <pre><code>namespace GameEngine {\n\nclass AComponent : public IComponent{\npublic:\nAComponent() {\n_id = 0;\n};\nAComponent(CONFIG::CompType type) : _type(type) {\n_id = 0;\n};\nAComponent(AComponent &amp;component) {\n_type = component.getType();\n_id = component.getId();\n_uuid = component.getUuid();\n};\nvirtual ~AComponent() = default;\ntemplate &lt;class Archive&gt;\n\nvoid serialize(Archive &amp; ar, const unsigned int version) {\nar.template register_type&lt;AComponent&gt;();\nar &amp; _id;\n// ar &amp; _uuid;\nar &amp; _type;\n}\n\nvirtual CONFIG::CompType getType() {return _type;};\nvirtual void setType(const CONFIG::CompType type) {_type = type;};\nvirtual int getId() {return _id;};\nvirtual void setId(const int id) {_id = id;};\nvirtual std::string getUuid() {return _uuid;};\n\nprotected:\nint _id;\nCONFIG::CompType _type;\nstd::string _uuid;\n};\n}\n</code></pre>"},{"location":"RTypes_docs/RTypes_docs/#_7","title":"Getting started","text":"[S]ystems <p>ISystem.hpp</p> <pre><code>namespace GameEngine {\n\nclass ISystem {\npublic:\nvirtual ~ISystem() = default;\nvirtual void update() = 0;\n};\n}\n</code></pre>"},{"location":"RTypes_docs/RTypes_docs/#_8","title":"Getting started","text":"<p>ASystem.hpp</p> <pre><code>namespace GameEngine {\n\nclass ASystem : public ISystem {\npublic:\nASystem(std::shared_ptr&lt;EntityManager&gt; &amp;entityManagerPtr) : _entityRefList(entityManagerPtr){}\nvirtual ~ASystem() = default;\n\nvirtual void update() {};\n\nprotected:\nstd::shared_ptr&lt;EntityManager&gt; &amp;_entityRefList;\n\nprivate:\n};\n}\n</code></pre> <p>back to top</p>"},{"location":"RTypes_docs/RTypes_docs/#usage","title":"[ Usage ]","text":"Beginner <ul> <li> <p>Create new map for RType</p> <p>This is a good example of a modification to help you understand the code as a whole.  The procedure for creating a new map is available in a dedicated CONFIG_MAP.md </p> </li> </ul> <p></p> Advanced <ul> <li> <p>Create Component</p> <ul> <li> <p>Info : The components in an ECS (Entity-Component-System) architecture of a C++ game engine are autonomous, reusable entities that encapsulate the specific behaviour and data of a game object, enabling modular and efficient management of the game's functionalities.</p> </li> <li> <p>Instruction : To create new components you need to add yourComponent.hpp in /GameEngine/Components/yourComponent.hpp . The synthax of an abstract component must of course be respected, see example. The name of your component must also be implemented in the /GameEngine/Utils/Config.hpp file in the list of component types named CompType.</p> </li> </ul> </li> </ul> <p>yourComponent.hpp <pre><code>#include  \"../../Components/AComponent/AComponent.hpp\"\n\nnamespace GameEngine {\n\nclass yourComponent : public AComponent  {\n\npublic:\nfriend class boost::serialization::access;\nfriend class AComponent;\n\nyourComponent() : AComponent(CONFIG::CompType::yourComponent) {}\nyourComponent(CONFIG::CompType  type,  int id, \"component parameters ...\")  :  AComponent(CONFIG::CompType::POSITION), _idComponent(id), _type(type), int id, \"component parameters ...\" {}\n\nvirtual  ~yourComponent()  =  default;\n\ntemplate&lt;class  Archive&gt;\nvoid  serialize(Archive  &amp;  ar,  const  unsigned  int  version)  {\nar.template  register_type&lt;Position&gt;();\nar &amp;  boost::serialization::base_object&lt;AComponent&gt;(*this);\n\nar &amp; _idComponent;\nar &amp; _type;\nar &amp; _xPos;\nar &amp; _yPos;\n}\n\n// Setter and getter function for your components value can be implement here\n\nvirtual CONFIG::CompType getType() {return _type;};\nvirtual void setType(const CONFIG::CompType type) {_type = type;};\nvirtual int getId() {return _idComponent;};\nvirtual void setId(const int id) {_idComponent = id;};\n\nprotected:\nint _idComponent;\nCONFIG::CompType _type;\n\nprivate:\n// your components value\n};\n}\n\nBOOST_CLASS_EXPORT_KEY(GameEngine::yourComponent);\n</code></pre></p> <p></p> <ul> <li> <p>Create System</p> <ul> <li> <p>Info : The systems in the ECS architecture of a C++ game engine are independent processing modules that define the overall behaviour of the game by interacting with the entity components, allowing the game logic to be organised and controlled in a separate and extensible way.</p> </li> <li> <p>Instruction : To create new system you need to add yourSys.hpp in /GameEngine/Systems/yourSystem.hpp . The synthax of an abstract systems must of course be respected, see example. Your systems will have access to the EntityManager, which allows you to manipulate entities. It will be useful for applying your systems to the entities you want.</p> </li> </ul> </li> </ul> <p>yourSystem.hpp <pre><code>#include  \"../ASystem/ASystem.hpp\"\n// Include Components needed here\n#include  \"../../Components/Position/Position.hpp\"\n#include  \"../../Utils/Timeout.hpp\"\n#include  &lt;chrono&gt;\n#include  &lt;random&gt;\n\nnamespace GameEngine {\n\nclass yourSys : public ISystem {\n\nyourSys(std::list&lt;std::shared_ptr&lt;Entity&gt;&gt;  &amp;entityList)  :  _entities(entityList),  isRunning(true)  {}\n~yourSys()  {};\n\nvirtual  void  update()  override  {\nfor  (std::shared_ptr&lt;Entity&gt;  &amp;entityPtr  :  _entities)  {\n// check or manipulate entities by type or by components type in entities\n}\n};\n\nprivate:\nbool  isRunning;\nstd::list&lt;std::shared_ptr&lt;Entity&gt;&gt;  _entities;\n\n};\n\n}   </code></pre></p> <p>back to top</p>"}]}